Strtucts
====

Struct 对齐问题
-------

	struct A{
		int a;
		char b;
		short c;
	};

	struct B{
		char b;
		int a;
		short c;
	};

这两个结构体的对象，空间大小不一样，前者8Byte, 12Byte

	a.第一个成员起始于0偏移处；
	b.每个成员按其类型大小和指定对齐参数n中较小的一个进行对齐；
	c.结构体总长度必须为所有对齐参数的整数倍；
	d.对于数组，可以拆开看做n个数组元素。


pragma  pack() 
------


	# pragma  pack(n) (n = 1 / 2 / 4 / 8 )

	( 1 )# pragma 是用来指挥编译器，或者说设置编译器的对齐方式的。编译器的默认对齐方式是 4 ，但是有时候我不希望对齐方式是 4 ，而希望是别的（譬如希望 1 字节对齐，也可能希望是 8 ，甚至可能希望 128 字节对齐）。
	( 2 )常用的设置编译器编译器对齐命令有 2 种：第一种是# pragma  pack()，这种就是设置编译器 1 字节对齐（有些人喜欢讲：设置编译器不对齐访问，还有些讲：取消编译器对齐访问）；第二种是# pragma  pack( 4 )，这个括号中的数字就表示我们希望多少字节对齐。
	( 3 )我们需要#prgama pack(n)开头，以# pragma  pack()结尾，定义一个区间，这个区间内的对齐参数就是n。
	( 4 )#prgma pack的方式在很多C环境下都是支持的，但是gcc虽然也可以不过不建议使用。








__attribute__
---------

__attribute__((packed))

__attribute__((aligned(n)))


__attribute__((packed))使用时直接放在要进行内存对齐的类型定义的后面，然后它起作用的范围只有加了这个东西的这一个类型。packed的作用就是取消对齐访问。

__attribute__((aligned(n)))使用时直接放在要进行内存对齐的类型定义的后面，然后它起作用的范围只有加了这个东西的这一个类型。它的作用是让整个结构体变量整体进行n字节对齐（注意是结构体变量整体n字节对齐，而不是结构体内各元素也要n字节对齐）

















:)
